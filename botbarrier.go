// Copyright 2025 Steffen Busch

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

// 	http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package botbarrier

import (
	"bytes"
	"context"
	"crypto/hmac"
	"crypto/rand"
	"crypto/sha512"
	"encoding/binary"
	"encoding/hex"
	"fmt"
	"html/template"
	"net"
	"net/http"
	"strconv"
	"time"

	"github.com/caddyserver/caddy/v2"
	"github.com/caddyserver/caddy/v2/modules/caddyhttp"
	"go.uber.org/zap"

	_ "embed"
)

//go:embed challenge_template.html
var defaultHTML string

//go:embed challenge.js
var embeddedJS string

// BotBarrier is a Caddy middleware module that requires clients to solve a computational challenge
// before granting access to HTTP resources. It helps mitigate bot traffic.
type BotBarrier struct {
	// Secret is the key used to generate and validate HMACs for the challenge seed.
	// If not provided, a random secret will be generated during provisioning.
	Secret string `json:"secret,omitempty"`

	// Complexity defines the number of leading zero bits required in the hash
	// (SHA512(seed || nonce)) for the challenge to be considered solved.
	// Higher values increase the difficulty of the challenge.
	// This can include placeholders like {vars.complexity}.
	Complexity string `json:"complexity,omitempty"`

	// ValidFor specifies the duration for which a challenge seed is valid.
	// After this duration, the client must solve a new challenge.
	ValidFor time.Duration `json:"valid_for,omitempty"`

	// SeedCookieName is the name of the cookie that stores the challenge seed.
	// Defaults to "__challenge_seed" if not specified.
	SeedCookieName string `json:"seed_cookie_name,omitempty"`

	// SolutionCookieName is the name of the cookie that stores the solution (nonce)
	// found by the client to solve the challenge. Defaults to "__challenge_solution".
	SolutionCookieName string `json:"solution_cookie_name,omitempty"`

	// MacCookieName is the name of the cookie that stores the HMAC of the challenge seed.
	// This ensures the seed was generated by the server. Defaults to "__challenge_mac".
	MacCookieName string `json:"mac_cookie_name,omitempty"`

	// TemplatePath specifies the path to a custom HTML template for the challenge page.
	// If not provided, a default embedded template will be used.
	TemplatePath string `json:"template,omitempty"`

	// logger provides structured logging for the module.
	logger *zap.Logger
}

func (BotBarrier) CaddyModule() caddy.ModuleInfo {
	return caddy.ModuleInfo{
		ID:  "http.handlers.bot_barrier",
		New: func() caddy.Module { return new(BotBarrier) },
	}
}

// Provision sets up the module, initializes the logger, and applies default values.
func (bb *BotBarrier) Provision(ctx caddy.Context) error {
	repl := caddy.NewReplacer()
	bb.logger = ctx.Logger(bb)

	if bb.Complexity == "" {
		bb.Complexity = "16" // Default complexity
	}
	if bb.ValidFor == 0 {
		bb.ValidFor = 10 * time.Minute
	}
	if bb.SeedCookieName == "" {
		bb.SeedCookieName = "__challenge_seed"
	}
	if bb.SolutionCookieName == "" {
		bb.SolutionCookieName = "__challenge_solution"
	}
	if bb.MacCookieName == "" {
		bb.MacCookieName = "__challenge_mac"
	}
	if bb.TemplatePath == "" {
		bb.TemplatePath = defaultHTML
	}

	// Replace placeholders in the secret such as {file./path/to/secret.txt}
	bb.Secret = repl.ReplaceAll(bb.Secret, "")
	if bb.Secret == "" {
		randomSecret := make([]byte, 32)
		_, err := rand.Read(randomSecret)
		if err != nil {
			return fmt.Errorf("failed to generate random secret: %v", err)
		}
		bb.Secret = hex.EncodeToString(randomSecret)
		bb.logger.Warn("No secret configured, generated a random secret", zap.String("secret", bb.Secret))
	}

	bb.logger.Info("BotBarrier module provisioned successfully",
		zap.String("complexity", bb.Complexity),
		zap.Duration("valid_for", bb.ValidFor),
		zap.String("seed_cookie_name", bb.SeedCookieName),
		zap.String("solution_cookie_name", bb.SolutionCookieName),
		zap.String("mac_cookie_name", bb.MacCookieName),
	)
	return nil
}

// Validate ensures the configuration is correct.
func (bb *BotBarrier) Validate() error {
	if bb.Secret == "" {
		return fmt.Errorf("secret must be configured")
	}

	// Validate complexity
	if _, err := strconv.Atoi(bb.Complexity); err != nil && bb.Complexity[0] != '{' {
		return fmt.Errorf("complexity must be an integer or a placeholder like {vars.complexity}, found: %s", bb.Complexity)
	}

	return nil
}

// ServeHTTP verifies the challenge cookies or returns a challenge page.
func (bb *BotBarrier) ServeHTTP(w http.ResponseWriter, r *http.Request, next caddyhttp.Handler) error {
	// Retrieve the client IP address from the Caddy context.
	clientIP := getClientIP(r.Context(), r.RemoteAddr)

	// Create logger with common fields
	logger := bb.logger.With(
		zap.String("client_ip", clientIP),
		zap.String("method", r.Method),
		zap.String("requested_url", r.URL.String()),
	)

	// Replace placeholders in Complexity
	repl := r.Context().Value(caddy.ReplacerCtxKey).(*caddy.Replacer)
	complexityStr := repl.ReplaceAll(bb.Complexity, "16")
	complexity, err := strconv.Atoi(complexityStr)
	if err != nil || complexity < 0 {
		logger.Error("Invalid complexity value after placeholder replacement, defaulting to 16", zap.String("complexity", complexityStr), zap.Error(err))
		complexity = 16 // Default to 16 if parsing fails
	}

	// Skip challenge if complexity is 0
	if complexity == 0 {
		logger.Info("Complexity is 0, skipping challenge")
		return next.ServeHTTP(w, r)
	}

	if bb.checkSolution(r, complexity, logger) {
		logger.Debug("Client passed the computational challenge")
		return next.ServeHTTP(w, r)
	}

	logger.Info("Client did not pass the computational challenge, serving challenge page")

	seed, err := bb.newSeed()
	if err != nil {
		logger.Error("Failed to generate seed", zap.Error(err))
		http.Error(w, "Seed generation failed", http.StatusInternalServerError)
		return nil
	}

	mac := bb.createMAC(seed)
	data := map[string]any{
		"Seed":           hex.EncodeToString(seed),
		"MAC":            hex.EncodeToString(mac),
		"Complexity":     complexity,
		"SeedCookie":     bb.SeedCookieName,
		"SolutionCookie": bb.SolutionCookieName,
		"MacCookie":      bb.MacCookieName,
		"MaxAge":         int(bb.ValidFor.Seconds()),
	}

	// Add a custom response header for the challenge page
	// This header helps identify responses serving the challenge page.
	// It can be useful for debugging, monitoring, or analytics purposes.
	w.Header().Set("X-Bot-Barrier", "challenge")

	if err := bb.renderChallengePage(w, data); err != nil {
		logger.Error("Failed to render challenge page", zap.Error(err))
		http.Error(w, "Failed to render challenge page", http.StatusInternalServerError)
		return nil
	}

	logger.Info("Challenge page served successfully")
	return nil
}

func (bb *BotBarrier) renderChallengePage(w http.ResponseWriter, data map[string]any) error {
	var tmpl *template.Template
	var err error

	if bb.TemplatePath == defaultHTML {
		tmpl, err = template.New("default").Parse(defaultHTML)
	} else {
		bb.logger.Debug("Loading custom template from file", zap.String("template_path", bb.TemplatePath))
		tmpl, err = template.ParseFiles(bb.TemplatePath)
	}
	if err != nil {
		return fmt.Errorf("failed to load template: %w", err)
	}

	// Process the embedded JavaScript as a template
	jsTemplate, err := template.New("script").Parse(embeddedJS)
	if err != nil {
		return fmt.Errorf("failed to process embedded script: %w", err)
	}

	var scriptBuffer bytes.Buffer
	if err := jsTemplate.Execute(&scriptBuffer, data); err != nil {
		return fmt.Errorf("failed to render script: %w", err)
	}

	data["Script"] = template.JS(scriptBuffer.String())
	w.Header().Set("Content-Type", "text/html")
	if err := tmpl.Execute(w, data); err != nil {
		return fmt.Errorf("failed to render template: %w", err)
	}

	return nil
}

// newSeed returns a seed with an embedded timestamp and random bytes.
func (bb *BotBarrier) newSeed() ([]byte, error) {
	seed := make([]byte, 16)
	now := uint64(time.Now().Unix())
	binary.BigEndian.PutUint64(seed[0:8], now)
	_, err := rand.Read(seed[8:])
	return seed, err
}

// createMAC generates an HMAC (Hash-based Message Authentication Code) for the given seed.
// The HMAC ensures that the seed was generated by the server and has not been tampered with.
// It uses the server's secret key to create the HMAC, which is stored in the MacCookie.
func (bb *BotBarrier) createMAC(seed []byte) []byte {
	mac := hmac.New(sha512.New, []byte(bb.Secret)) // Use the secret key to initialize the HMAC
	mac.Write(seed)                                // Add the seed to the HMAC
	return mac.Sum(nil)                            // Return the resulting HMAC
}

// checkSolution verifies the computational challenge solution provided by the client.
// It ensures that:
// - The seed was generated by the server (validated using the MacCookie and the secret key).
// - The seed is still within the allowed time window (validated using the timestamp in the seed).
// - The client solved the challenge by finding a nonce that produces a hash with enough leading zero bits.
func (bb *BotBarrier) checkSolution(r *http.Request, complexity int, logger *zap.Logger) bool {
	logger.Info("Checking computational challenge solution", zap.Int("required_complexity", complexity))

	// Retrieve cookies from the client's request
	seedCookie, errSeed := r.Cookie(bb.SeedCookieName)
	solutionCookie, errSolution := r.Cookie(bb.SolutionCookieName)
	macCookie, errMac := r.Cookie(bb.MacCookieName)

	// Ensure all required cookies are present
	if errSeed != nil || errSolution != nil || errMac != nil {
		logger.Info("Missing required cookies")
		return false
	}

	// Decode the seed from the cookie
	seedBytes, err := hex.DecodeString(seedCookie.Value)
	if err != nil {
		logger.Warn("Invalid seed format", zap.String("seed", seedCookie.Value), zap.Error(err))
		return false
	}

	// Validate the seed and get its age
	age, valid := bb.isSeedValid(seedBytes)
	if !valid {
		logger.Warn("Expired seed", zap.String("seed", seedCookie.Value), zap.Duration("age", age), zap.Duration("valid_for", bb.ValidFor))
		return false
	}

	// Validate the MAC to ensure the seed was generated by the server
	macBytes, err := hex.DecodeString(macCookie.Value)
	if err != nil || !hmac.Equal(macBytes, bb.createMAC(seedBytes)) {
		logger.Warn("Invalid MAC", zap.String("mac", macCookie.Value), zap.Error(err))
		return false
	}

	// Decode the solution (nonce) from the cookie
	solutionBytes, err := hex.DecodeString(solutionCookie.Value)
	if err != nil {
		logger.Warn("Invalid solution", zap.String("solution", solutionCookie.Value), zap.Error(err))
		return false
	}

	// Combine the seed and solution to calculate the hash
	combined := append(seedBytes, solutionBytes...)
	hash := sha512.Sum512(combined)

	// Count the number of leading zero bits in the hash
	leadingZeroBits := countLeadingZeroBits(hash[:])

	// Verify that the hash meets the required complexity
	if leadingZeroBits >= complexity {
		logger.Info("Computational challenge solution valid",
			zap.Int("leading_zero_bits", leadingZeroBits),
			zap.Int("required_complexity", complexity),
			zap.Duration("seed_age", age),
			zap.Duration("valid_for", bb.ValidFor),
		)
		return true
	}

	logger.Warn("Computational challenge solution invalid",
		zap.Int("leading_zero_bits", leadingZeroBits),
		zap.Int("required_complexity", complexity),
	)
	return false
}

// isSeedValid checks if the timestamp embedded in the seed is within the allowed time window.
// This ensures that the seed is not too old and prevents replay attacks.
func (bb *BotBarrier) isSeedValid(seed []byte) (time.Duration, bool) {
	if len(seed) < 8 {
		bb.logger.Warn("Seed too short", zap.Int("length", len(seed)))
		return 0, false
	}
	ts := binary.BigEndian.Uint64(seed[0:8]) // Extract the timestamp from the first 8 bytes of the seed
	now := uint64(time.Now().Unix())
	age := time.Duration(now-ts) * time.Second
	if age >= 0 && age <= bb.ValidFor {
		bb.logger.Debug("Seed is valid", zap.Duration("age", age), zap.Duration("valid_for", bb.ValidFor))
		return age, true
	}
	return age, false
}

// countLeadingZeroBits returns the number of leading zero bits in a byte slice.
// This is used to determine if the hash meets the required complexity.
func countLeadingZeroBits(data []byte) int {
	count := 0
	for _, b := range data {
		for i := 7; i >= 0; i-- {
			if (b>>i)&1 == 0 {
				count++
			} else {
				return count
			}
		}
	}
	return count
}

// getClientIP retrieves the client IP address directly from the Caddy context.
func getClientIP(ctx context.Context, remoteAddr string) string {
	clientIP, ok := ctx.Value(caddyhttp.VarsCtxKey).(map[string]any)["client_ip"]
	if ok {
		if ip, valid := clientIP.(string); valid {
			return ip
		}
	}
	// If the client IP is empty, extract it from the request's RemoteAddr.
	var err error
	clientIP, _, err = net.SplitHostPort(remoteAddr)
	if err != nil {
		// Use the complete RemoteAddr string as a last resort.
		clientIP = remoteAddr
	}
	return clientIP.(string)
}

// Interface guards to ensure BotBarrier implements the necessary interfaces.
var (
	_ caddy.Module                = (*BotBarrier)(nil)
	_ caddy.Provisioner           = (*BotBarrier)(nil)
	_ caddy.Validator             = (*BotBarrier)(nil)
	_ caddyhttp.MiddlewareHandler = (*BotBarrier)(nil)
)
